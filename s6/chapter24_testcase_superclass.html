<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script type="text/javascript" src="s6.js"></script>
<script type="text/javascript" src="s6setup.js"></script>
</head>
<body>
<h1>Testcase Sueprclass</h1>
<address>yujiorama</address></div><div>
<p><em>Where do we put our test code when it is in reusable Test Utility Methods?</em></p>
<p><strong>We inherit reusable test-specific logic from an abstract Testcase Super class.</strong></p>
<ul>
<li>テストを書いていると、必ず同じロジックが必要になることがある</li>
<li>最初のうちは、コピペしてしまうものです</li>
<li>最終的には、<em>Test Utility Methods</em> (pp.599) パターンにするが、どこに置いたらいいのか ?</li>
<li><em>Testcase Superclass</em> パターンは、<em>Test Utility Methods</em> の置き場所として 1 つの選択肢になります。</li>
</ul>
</div>
<h2>How It Works</h2>
<ul>
<li>さまざまなテストケースクラスで再利用可能なテストユーティリティメソッドを、抽象基底クラスに定義します</li>
<li>メソッドは、Java なら protected のように、サブクラスから見えるようにします</li>
<li>この抽象基底クラスを親クラスとして使用します</li>
</ul>
</div>
<h2>When to Use It</h2>
<ul>
<li>さまざまなテストケースクラスで <em>Test Utility Methods</em> を再利用したいとき</li>
</ul>
<ul>
<li>使用してる言語が継承をサポートしている</li>
<li>このパターンと衝突するような目的で継承を使ってない</li>
<li>テストユーティリティメソッドが基底クラスから見えない型を参照しなくてもよい</li>
</ul>
<ul>
<li><em>Testcase Superclass</em> と <em>Test Helper</em> (pp.643) を使い分ける基準は、型の可視性</li>
</ul>
<ul>
<li>クライアントクラスがテストユーティリティメソッドを見れなければいけない</li>
<li>テストユーティリティメソッドは依存している型やクラスを見れなければいけない</li>
</ul>
<ul>
<li>テストユーティリティメソッドが、あまり多くの型/クラスに依存していなかったり、依存してるすべての型/クラスが single place からしか見えない<ul>
<li>社内やプロジェクト内の共通テストケース基底クラスに入れる</li>
</ul></li>
</ul>
<ul>
<li>テストユーティリティメソッドが、すべてのクライアントからアクセスできる single place から見れない型/クラスに依存している<ul>
<li>適切なパッケージ、サブシステムに配置される <em>Test Helper</em> に入れる</li>
</ul></li>
</ul>
</div>
<h3>Variation: Test Helper Mixin</h3>
<ul>
<li>Mix-in をサポートしてる言語ではもっともよい方法です</li>
<li>単一継承の制約なしに、Mix-in する <em>Test Helper</em> を選択できます</li>
</ul>
<ul>
<li><em>Test Helper Object</em> の場合<ul>
<li>テスト特有の状態は Mix-in に保持されるが、インスタンス化や委譲は不要です</li>
</ul></li>
</ul>
<ul>
<li><em>Testcase Superclass</em> の場合<ul>
<li>すべてにおいてメソッド呼び出しや自分の属性としてアクセスできます</li>
</ul></li>
</ul>
</div>
<h2>Implementation Notes</h2>
<ul>
<li>テスティングフレームワークが、フレームワークの提供する <em>Testcase Superclass</em> を基底クラスとすることを要求する場合<ul>
<li>すべてのテストケースクラスは、その基底クラスのサブクラスになります</li>
</ul></li>
</ul>
<ul>
<li>テスティングフレームワークが、テストメソッドを特定するためにアノテーションやメソッドの属性を使う場合<ul>
<li>テストケースクラスは、私達が便利だと思うクラスのサブクラスにできます</li>
</ul></li>
</ul>
<ul>
<li><em>Testcase Superclass</em> パターンでは、クラスメソッドとインスタンスメソッドのどちらでも実装できます<ul>
<li>状態を持たない <em>Test Utility Methods</em> は、クラスメソッドでいいでしょう</li>
<li>なんかの理由があればインスタンスメソッドにすればいいでしょう</li>
</ul></li>
</ul>
<ul>
<li>どちらにしても、それらを継承したテストケースクラスからは、自身のメソッドのようにアクセスすることができます</li>
</ul>
<ul>
<li>メソッドの可視性を管理できる言語を使っているなら、少しくらい余計に見えるようにしておきましょう<ul>
<li>Java なら protected</li>
</ul></li>
</ul>
</div>
<h2>Motivating Example</h2>
</div>
<h2>Refactoring Notes</h2>
</div>
<h3>Example: Testcase Superclass</h3>
</div>
<h3>Example: Test Helper Mixin</h3>
<ul>
<li><em>Test Code Duplication</em> (pp.213) が見あたります</li>
<li><em>メソッドの抽出</em> により、テストユーティリティメソッドを作成します</li>
<li>再利用性のため、<em>Pull Up Method</em> により、Test Helper Mixin に移動します</li>
</ul>
</div>
</body>
</html>
