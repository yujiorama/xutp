<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script type="text/javascript" src="s6.js"></script>
<script type="text/javascript" src="s6setup.js"></script>
</head>
<body>
<div>
<h1>Testcase Class per Fixture</h1>
<address>yujiorama</address>
<p><em>How do we organize our Test Methods onto Testcase Classes?</em></p>
<p><strong>フィクスチャーの共通性を元にテストメソッドをまとめる</strong></p>
<ul>
<li><em>Test Methods</em> (pp.348) が増加するにつれて、どの <em>Testcase Class</em> (pp.373) に配置するかを決めなければいけなくなる</li>
<li><em>Testcase Class per Fixture</em><ul>
<li>私達が「テストの全体像を容易に理解できるようになる」ことに作用するテスト組織化の戦略</li>
<li>フィクスチャーセットアップの方法にも影響する</li>
<li><em>Test Automation Framework</em> (pp.298) が提供する <em>Implicit Setup</em> (pp.424) の仕組みが効果的に使えるようになります</li>
</ul></li>
</ul>
</div>
<div>
<h2>How It Works</h2>
<ul>
<li>必要とするテストフィクスチャーを元にテストメソッドを集めます</li>
<li><em>Implicit Setup</em> のようなフィクスチャーを生成するロジックを setUp メソッドに移動することができます</li>
<li>4 フェーズテスト (pp.358) における exercise、および verify フェーズに集中することができます</li>
</ul>
</div>
<div>
<h2>When to Use It</h2>
<ul>
<li>同じフィクスチャーを使うテストメソッドのグループがあり、それらを単純にしたいときのためのパターンです</li>
<li>個々のフィクスチャーが必要な場合はあんまり意味がありません<ul>
<li>テストメソッドが 1 つだけの大量のテストクラスが作成されるからです</li>
<li><em>Testcase Class per Feature (pp.624) か </em>Testcase Class per Class'' (pp.617) を使うべきです</li>
</ul></li>
</ul>
<ul>
<li>テストの実行が始まる状態を容易に把握できるようになります</li>
<li>テストケースクラスごとのテストメソッドが同じ並び方になります<ul>
<li>IDE の "メソッドブラウザ" や "アウトラインビュー" で一瞥できます</li>
<li>だいぶ前に商用リリースしたコードの <em>Missing Unit Tests</em> (Production Bugs, pp.268) を見つけるのに便利です</li>
</ul></li>
</ul>
<ul>
<li>振る舞い駆動開発におけるテスティング、仕様決定の重要なポイントです</li>
<li>アサーションが 1 つだけのようなとても短いテストメソッドを書くようになります</li>
<li>テストの期待結果の要約を含むような命名規約と組み合せることで、<em>Tests as Documentation</em> (pp.23) を推進します</li>
</ul>
</div>
<div>
<h2>Implementation Notes</h2>
<ul>
<li>フィクスチャの生成は <em>Test Automation Framework</em> が setUp メソッドで行う</li>
<li>フィクスチャへの参照はインスタンス変数に持たなければなりません</li>
<li>クラス変数を使わないように注意<ul>
<li><em>Shared Fixture</em> (pp.317) になりやすい</li>
<li>ひきずられて <em>Erratic Test</em> (pp.228) になりやすい</li>
</ul></li>
</ul>
<ul>
<li>コラム "There's Always an Exception" (pp.384)<ul>
<li>インスタンス変数を使っているからといって <em>Independent Test</em> (pp.42) にならない xUnit ファミリーを紹介</li>
<li>NUnit2.0、TestNG</li>
<li>NUnit の作者は「失敗だった」と言っている</li>
</ul></li>
</ul>
<ul>
<li>各テストケースクラスには 1 つのテストフィクスチャ</li>
<li>テストケースクラスの名前はそのフィクスチャを元にしたものになるのが当然</li>
</ul>
<ul>
<li>同様に、テストメソッドの名前は exercise する SUT を元にしたものになる<ul>
<li>SUT メソッドの引数の特徴やメソッド呼び出しの期待結果とか</li>
</ul></li>
</ul>
<ul>
<li>副作用: 1 つの SUT クラスを検証するためにたくさんのテストケースクラスが作られてしまう<ul>
<li>ネストしたフォルダ/パッケージ/名前空間を使ってまとめる</li>
<li><em>Test Enumeration</em> (pp.399) を使っているなら、<em><a href="AllTests">AllTests</a> Suite</em> (Named Test Suite, pp.592) によって 1 つのテストスイートにまとめる</li>
</ul></li>
</ul>
<ul>
<li>副作用: SUT の 1 つの機能に対するテストがたくさんのテストケースにちらばる<ul>
<li>機能間の相互依存性を際立たせるのでよいことかもしれない</li>
</ul></li>
</ul>
<ul>
<li>機能間の関連がほとんどなくては不安になったときの処置<ul>
<li>テストを <em>Testcase Class per Feature</em> にリファクタリングする</li>
<li>SUT が責務を持ちすぎていることを意味するので SUT をリファクタリングする</li>
</ul></li>
</ul>
</div>
<div>
<h2>Motivating Example</h2>
<ul>
<li><em>Testcase Class per Class</em> パターンで構成された Flight クラスのテスト<ul>
<li>3 つの状態 (Unscheduled, Schedule, <a href="AwaitingApproval">AwaitingApproval</a>)</li>
<li>4 つのメソッド (schedule, requestApproval, deSchedule, approve)</li>
</ul></li>
</ul>
</div>
<div>
<h2>Refactoring Notes</h2>
<ul>
<li>フィクスチャーの生成における <em>Test Code Duplication</em> (pp.213) を取り除きます</li>
</ul>
<ul>
<li>元のテストクラスが使っているフィクスチャーが 1 つになるまで、これらのプロセスを繰り返します<ol>
<li>フィクスチャーとして生成するクラスの数と、どのテストメソッドを 1 つのテストクラスに入れるのかを決める</li>
<li><em>クラスの抽出</em> により、必要なフィクスチャーを説明した名前を付けたテストケースクラスを作成する</li>
<li><em>メソッドの移動</em> により、必要なインスタンス変数と一緒にテストメソッドを新しいクラスに移動する</li>
</ol></li>
</ul>
<ul>
<li>全て完了するまでの間に、テストケースクラスがコンパイル・実行できるようにしましょう</li>
</ul>
<ul>
<li><em>Testcase Class per Fixture</em> パターンの利点を最大化するための残り 2 つの手順<ol>
<li>各テストメソッドにあるフィクスチャーの生成ロジックを、setUp メソッドに移す (<em>Implicit Setup</em> にする)<ul>
<li>同じフィクスチャーを使うテストメソッドを集めているからできるはず</li>
</ul></li>
<li>テストメソッドの名前を、それが検証する結果を表すように変更する<ul>
<li>テストケースクラス名からテストの初期状態は分かるので、初期状態に関する表現はメソッド名から除去してもよい</li>
</ul></li>
</ol></li>
</ul>
<ul>
<li>リファクタリングによって、テストメソッド名にテストすることと期待結果を含めるような世界から開放された</li>
</ul>
</div>
<div>
<h3>Example: Testcase Class per Fixture</h3>
</div>
</body>
</html>
