Chapter26. Humble Object
========================

- How can we make code testable when it is too closely coupled to its environment?
- **We extract the logic into a separate, easay-to-test component that is decoupled from its environment.**

- - -

- なんらかのフレームワークに密結合されたソフトウェアをテストしなければならない、という状況
- 本章の例で扱っているもの
    - visual components (ウィジェットやダイアログ)
    - transactional component plug-ins
- これらのオブジェクトのテストは大変
    - オブジェクトを生成するための SUT とのやりとりが重い (be expensive)
    - 不可能だったりする
    - 非同期で動作する場合もある
        - 本章の例で扱っているもの
        - active objects (スレッド、プロセス、Web サーバ)
        - user interfaces
    - 非同期処理による不確実性をテストで扱うために必要なこと
        - interprocess coordination
        - 遅延させる機能
- 一般的にはこういったコードのテストは諦められてしまうが悪い結果になる
    - *Untested Code* になる
    - *Untested Requirements* ができる
    - *Production Bugs* が発生する
- *Humble Object*
    - インスタンスの生成がハードなオブジェクトが持つロジックを、効率的なやりかたでテストに持ち込む方法です


[Humble Object] How it Works
----------------------------

- 「テストしづらいコンポーネント」のロジックを、「テストしやすいコンポーネント」に移動します
    - **synchronous tests** なのでテストしやすいんです
    - テストしやすいコンポーネント
        - テストしづらいコンポーネントのロジックを公開するためのメソッドを持つサービスインターフェースを実装してます
        - 唯一の違いは同期的なメソッド呼び出しができることです
- *Humble Object* は、少しのコードからなる薄いアダプタです
- フレームワークによる *Humble Object* の呼び出しは、「テストしやすいコンポーネント」に委譲されます
- *Humble Object* には、「テストしやすいコンポーネント」が必要とするコンテキストの情報を渡す責務があります
- *Humble Object* のコードはとても小さいけど、テストを実行するための setup がとても大変なので、書くのが退屈なんてことにはなりません


[Humble Object] When to Use It
------------------------------

- フレームワークに依存してる or 非同期な呼び出ししかできない。なのになんだか複雑なロジックを持ってるコンポーネントがある
    - *Humble Object* を取り入れましょう
- テストが大変になってしまうのにはいろんな理由があります
    - 依存関係を切るためのやりかたもいろんな方法になります
- 本章の variations はよくあるパターンです
    - 自前の variation を考案しても驚くことではないです


### Variation: Humble Dialog

- GUI フレームワークは、ページやコントロールを表示するためにオブジェクトを要求してきます
- GUI フレームワークが必要とするオブジェクトの提供するロジック
    - ユーザの操作をシステムに伝えます
    - システムの応答をユーザの認識できる振る舞いとして伝えます
    - ユーザインターフェースの裏でアプリケーションを呼び出します
    - 自分や他の visual object の状態を変えます

- Visual object の効率的なテストはとっても大変
    - プレゼンテーションフレームワークとの結合が密すぎる
    - テストは、環境をシミュレートして、visual object が必要とする情報や設備 (属性?機能?) を提供しないといけない

- Visual object の効率的なテストは本当に大変
    - フレームワークが管理してる専用のスレッドから使用してることがある (# SWT とかそうですね)
    - **asynchronous test** を使わざるを得ない
        - とてもチャレンジング
        - *Slow Test* になってしまう
        - *Nondeterminisitic Test* になってしまう

*Humble Object* によって解決できるのです!


### Variation: Humble Executable

- active object は自分用のスレッドを持っているので、並行に動作することができます
    - Windows アプリケーション (.exe) は別々のプロセスで動くことができます
    - (Java では) Runnable を実装したオブジェクトは別々のスレッドで動くことができます
    - クライアントが起動することもあれば、自動的に開始することもあります
    - キューからリクエストされたプロセスは、return message として応答を送ります
- どっちにしてもテストするには **asynchronous test** を使わざるを得ない
    - interprocess coordination
    - 遅延させる機能
    - *Neverfail Test*

- *Humble Executable* パターン
    - *Slow Test* にも *Nondeterminisitic Test* にもならない唯一つの方法です
    - executable の全てのロジックを **synchronouse test** 可能なコンポーネントに移します
    - このコンポーネントが実装するサービスインターフェース
        - executable の全てのロジックをメソッドとして公開してる
        - メソッドは同期呼び出しできる
    - テスタブルコンポーネントは DLL (Windows) や JAR (Java) になるでしょう

- *Humble Executable* コンポーネントの特徴
    - 小さいコード
    - フレームワーク側のスレッドからは、テスタブルコンポーネント (*True Humble Object*?) をロードしてメッセージを委譲するだけ
    - テストは、1 つか 2 つ (load できること、委譲できること) で済みます
    - 実行にかかる時間はばかにできないので、数が少なくてもテストスイートの実行時間には大きな影響がある
    - そうそう変わるものでもないので、開発者用のテストスイートからは外してもいいかも
    - 自動化ビルドのテストスイートには入れておくことをお勧めします


### Variation: Humble Transaction Controller

- データベースを使うアプリケーションのテスト
    - フィクスチャーのセットアップは遅いし複雑になりがち
    - フィクスチャーにゴミがあると次のテストの実行に混乱を招く
        - wreak (漏らす、ぶちまける)。havoc (大破壊、大混乱)
    - *Shared Fixture* を使ってる場合は、フィクスチャーの永続化によって *Erratic Test* になるかも

- *Humble Transaction Controller* の目的
    - テストコードからトランザクションを制御できるようにします
    - データベースに痕跡を残しません
    - トランザクション内で実行されるロジックのテストが楽になります

- *Humble Transaction Controller* の実装
    - トランザクション内の処理を **Extract Method** で別のメソッドにします
    - このメソッドはトランザクションのことを何も知らないようにしておきます
    - テストがトランザクションを開始したりコミットしたりロールバックできるようにするためです
    - このような振る舞い(依存性ではない)が、ビジネスロジックのテストにおいて *Humble Object* をバイパスさせます
    - 結論: *Poor Man's Humble Object* を使うことで、うまくテストができるようになります

- *Humble Object* にはビジネスロジックがありません
    - テストすべき振る舞いは、メソッド呼び出しによってコミット、ロールバックがちゃんと行われることです
    - テスタブルコンポーネントを、例外をスローする *Test Stub* で置き換えて、トランザクションがロールバックされることを検証できます
    - *Poor Man's Humble Object* の場合は *Subclassed Test Double* で本物メソッドをオーバーライドします

- たいていのアプリケーションサーバはこのパターンをサポートしてます
    - ビジネスオブジェクトの外でトランザクションを直接、または間接的に制御できます
- トランザクション制御を持ったフレームワークを使わないなら、自分達でこのパターンを実装しましょう


### Variation: Humble Container Adapter

- アプリケーションサーバの中で私たちのオブジェクトを実行させるためには、指定されたインターフェースを実装しないといけない
    - EJB session bean interface
- *Humble Container Adapter* パターンで、コンテナに依存しないオブジェクトを設計しましょう
- コンテナがいらないのでテストしやすくなります
    - "edit-compile-test" のサイクルを回す時間が劇的に短くなります


[Humble Object] Implementation Notes
------------------------------------

- テストしやすくするために *Humble Object* を導入する方法はいろいろあります
- ロジックを公開することで同期テストで検証しやすくなる、というところは共通してます
- TDD 純粋主義者は「テストで、"*Humble Object* が公開されたロジックを正しく呼び出すこと"、を検証する」ことを推奨してます


### Variation: Poor Man's Humble Object

- ロジックを部分部分に隔離したり公開するには、別のメソッドにするのが簡単です
- インラインロジックを **Extract Method** して、テストから見れるようにします

- 公開されたメソッドは、コンテキストに何も要求できません
- 理想的には必要な情報はすべて引数として渡すんですが、フィールドに置くこともできます
- 問題はテスタブルコンポーネントからこのメソッドを呼び出した際に、必要な情報がコンテキスト (存在しない、もしくは偽物) に依存してるような場合です

- "poor man's" *Humble Object* はこういった方法から構成されます
- オブジェクト (*Humble Object*) のインスタンス化を妨げるようなものがなければうまく機能するのです
    - 自動的に開始するスレッド
    - public なコンストラクタがない
    - 満たされない依存性
- *Test Specific Subclass* でこういった依存性を切ることができます
    - テストしやすいコンストラクタ
    - private メソッドをテストに公開する

- *Subclassed Humble Object* や *Poor Man's Humble Object* のテスト
    - テスト対象のメソッドがどう呼ばれるか分からないときに、その呼び出しを記録します
        - *Subclassed Test Double* (*Test Spy*) を作ります
    - 記録した結果と期待する結果を *Test Method* で検証します


### Variation: True Humble Object

- 極端な例です
    - テストしたいロジックは別のクラスに入れます
    - *Humble Object* にそのクラスのインスタンスを持たせて、メソッド呼び出しを委譲させます
    - コードが完全に管理できてるならうまくいきます

- たいていの場合、私たちのオブジェクトをホストしてるフレームワークには、どうしようもない特定の責務があります
    - GUI フレームワーク
        - ビューオブジェクトは GUI を制御するためのデータを持ってます
        - データは画面に表示されます
- 2 つの選択肢があります
    - *Humble Object* にテスタブルなオブジェクトの参照を持たせて、オブジェクトのデータを操作できるようにしておきます
    - *Humble Object* に最小限の更新ロジックを入れてしまいます
        - 自動化テストではカバーできないロジックであることを受け入れます
- たいていは前者の方法で大丈夫ですしお勧めです

- *True Humble Object* へのリファクタリング
    1. 他のインスタンスに委譲させたい実装ロジックが public interface になるよう、*Extract Method* を繰り返し適用して分解します
    2. *Humble Object* として定義する以外のメソッドを、*Extract Class* したテスタブルなクラスに移動します
    3. フィールドに、テスタブルなオブジェクトの参照を追加します
        - フィールドは、インターフェースのメソッドごとに初期化します
            - コンストラクタで生成してもよし
            - **Lazy Initialization** してもよし

- *True Humble Object* のテスト
    - *Lazy Mock Objec* または *Test Spy* を使います
        - extract されたクラスが意図したとおりに呼ばれていることを確認するのです
    - 対照的に、こういった状況では一般的な *Active Mock Object* は少々やっかいです
        - assertion が *Testcase Object* と別のスレッドで評価されます
        - テストをしているスレッドを観測しないと、失敗が検出できません

- extract されたテスタブルコンポーネントが正しくインスタンス化されることを保証するやりかた
    - ovservable な *Object Factory* を使わせる
    - テストから、リスナーオブジェクトを登録
    - ファクトリのメソッド呼び出しを検証します
    - 通常の **factory** オブジェクトを使うことも可能
    - 振る舞いを観測するため、テストのときだけ *Mock Object* か *Test Stub* に置き換えてしまえばよい


### Variant: Subclassed Humble Object

- ロジックを別のクラスに隔離するための中間的なアプローチ
- よくあるパターン 2 つ
    1. テストしたいメソッドを持ったフレームワークに依存しているクラスを subclass 化する
    2. subclass によって実装される抽象メソッドへの委譲をしてるようなクラス
