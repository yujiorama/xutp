{{toc}}

! Stored Procedure Test

''How can we verify logic independently when we have stored procedures?''

'''We write Fully Automated Tests for each stored procedure.'''


* アプリケーションには、その状態を永続化するためにデータベースを使用するものがあります
** 中には、ストアドプロシージャやトリガーを使ってパフォーマンスを稼いだり、更新処理を共通化したりしてます

* このパターンは、データベースの中に置いてあるコードについて、テスト自動化のプラクティスを適用します

!! How It Works

* アプリケーションとは独立して、ストアドプロシージャのためのユニットテストを書きます
** レイヤー交差テスト、回帰テストになります
** テスト対象のストアドプロシージャの性質によって変わります

!! When to Use it

* 重要なロジックをストアドプロシージャに置いてるなら、テストを書くべきです
** ストアドプロシージャが SUT になります
** アプリケーションとは独立して検証できるようになります

* ''Stored Procedure Tests'' が重要なテストになるケース
** 1 つ以上のアプリケーションから利用されるような場合
** 他のチームによって開発される場合
** アプリケーションのテストによって適切にテストされることが保証できない場合
*** Indirect Testing のようなテスト

* ストアドプロシージャが呼ばれるような全ての状況を列挙し、その振る舞いを確認できます
** 状況をよく検討することで、設計を進歩できます
** TDD の普遍的な成果です

!! Implementation Notes

# ストアドプロシージャと同じ言語でテストを書いて、データベース側で実行する
# アプリケーションの言語でテストを書いて、''Remote Proxy''[GOF] でストアドプロシージャにアクセスする

* どちらの方法でもテストは書けます
* ストアドプロシージャの開発担当者は (1) の方法でユニットテストを書くでしょう
* アプリケーションの開発担当は (2) の方法で受け入れテストを書くでしょう
** そしてアプリケーションのビルド時に実行するでしょう

* どちらにしても、フィクスチャーの生成や、期待結果の検証をどうするか決めなければなりません
** "before": テスト前のデータベース
** "after": cascading delete などの期待する振る舞いの後のデータベース

* テストは、データの insert や verify をするために直接データベースとやりとりすることになるでしょう
** ''Back Door Manipulation'' (pp.327)
** 他のストアドプロシージャも使えるでしょう (回帰テストの一種)

!!! Variation: In-Database Stored Procedure Test

テスト自動化に xUnit を使う利点は、テスト対象のコードと同じ言語でテストを書けることです

開発者に自動テストを学んでもらうために、新たな言語やデバッガを学習することなく、

One advantage of the xUnit approach to automated testing is that the
tests are written in the same language as the code we are
testing. This makes it easier for the developers to learn how to
automate the tests without learning a new program- ming language,
debugger, and so on. Extending this idea to its logical conclusion, it
makes sense to test stored procedures using tests that are written in
the stored- procedure programming language. Naturally, we will need to
run these tests inside the database. Unfortunately, that requirement
may make it hard to run them as part of the Integration Build [SCM].

This variation on the Stored Procedure Test pattern is appropriate
when we have more experience writing code in the stored-procedure
language and/or environment than in the application environment and it
is not essential that all tests be run from a single place. For
example, a database or data services team that is writing stored
procedures for use by other teams would find this approach
attractive. Another circumstance in which it would be appropriate to
use In-Database Stored Procedure Tests arises when the procedures are
stored in a different source code repository than the application
logic. Using In-Database Stored Procedure Test allows us to store the
tests in the same repository as the SUT (in this case, the stored
procedures).

In-Database Stored Procedure Tests may allow somewhat more thorough
unit testing (and test-driven development) of the stored procedures
because we may have better access to implementation details of the
stored procedure from our tests. Of course, this violation of
encapsulation could result in Overspecified Software (see Fragile Test
on page 239). If the client code uses a data access layer, we must
still write unit tests for that software in the application
programming language to ensure that we handle errors correctly (e.g.,
failure to connect).

Some databases support several programming languages. In such a case,
we can choose to use the more test-friendly programming language for
our tests but write the stored procedures in the more traditional
stored-procedure programming language. For example, Oracle databases
support both PLSQL and Java, so we could use JUnit tests to verify our
PLSQL stored procedures. Likewise, Microsoft’s SQL Server supports
C#, so we could use NUnit tests written in C# to verify the stored
procedures written in Transact-SQL.

!! Motivating Example

!! Refactoring Notes
