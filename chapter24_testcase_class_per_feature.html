<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script type="text/javascript" src="s6.js"></script>
<script type="text/javascript" src="s6setup.js"></script>
</head>
<body>
<div>
<h1>Testcase Class per Feature</h1>
<address>yujiorama</address>
<p><em>How do we organize our Test Methods onto Testcase Classes?</em></p>
<p><em>We group the Test Methods onto Testcase Classes based on which testable feature of the SUT they exercise.</em></p>
<ul>
<li><em>Test Methods</em> (pp.348) が増加するにつれて、どの <em>Testcase Class</em> (pp.373) に配置するかを決めなければいけなくなる</li>
<li><em>Testcase Class per Feature</em><ul>
<li>私達が「テストの全体像を容易に理解できるようになる」ことに作用するテスト組織化の戦略</li>
<li>フィクスチャーセットアップの方法にも影響する</li>
<li>テストメソッドを壊さずに、巨大なテストケースクラスをいくつかの小さなクラスに分割する体系的な方法を与えるものです</li>
</ul></li>
</ul>
</div>
<div>
<h2>How It Works</h2>
<ul>
<li>テストメソッドが、検証されるべき機能ごとに用意されたテストケースクラスに集まります</li>
<li>より小さいテストケースクラスが得られます</li>
<li>特定の機能についてのテスト結果を一瞥することができるようになります</li>
</ul>
</div>
<div>
<h2>When to Use It</h2>
<ul>
<li><em>Testcase Class per Feature</em> を使う状況<ul>
<li>大量のテストメソッドを持っている</li>
<li>SUT の提供する機能 (feature) の仕様を明確にしたいと望んでいる</li>
</ul></li>
<li><em>Testcase Class per Feature</em> が実現しないこと<ul>
<li>個々のテストメソッドを単純にできるわけではない</li>
<li>テストメソッド自体が分かりやすくなるわけではない</li>
<li>これらは <em>Testcase Class per Fixture</em> (pp.631) によって解決されます</li>
</ul></li>
<li><em>Testcase Class per Feature</em> を使ってもしょうがない状況<ul>
<li>SUT の個々の機能がせいぜい 1 つか 2 つのテストメソッドしか必要としていない</li>
<li><em>Testcase Class per Class</em> (pp.617) で十分でしょう</li>
</ul></li>
</ul>
<ul>
<li>あるクラスがいくつもの機能を持っていること自体が一種の"悪臭"(smell) です<ul>
<li>責務が多すぎ</li>
</ul></li>
<li><em>Testcase Class per Feature</em> を使う典型的な状況<ul>
<li>ファサードクラスのメソッドに対する顧客テスト</li>
</ul></li>
</ul>
</div>
<div>
<h3>Variation: Testcase Class per Method</h3>
<ul>
<li>引数に様々なパラメータを受け取るメソッドには、多くのテストが必要になります</li>
<li>この 1 つのメソッドに対するテストメソッドは 1 つの <em>Testcase Class per Method</em> にしましょう</li>
<li>残りは他のテストケースクラスに入れましょう</li>
</ul>
</div>
<div>
<h3>Variation: Testcase Class per Feature</h3>
<ul>
<li>あるクラスの "feature" は普通は 1 つの操作ないし関数になります</li>
<li>しかし、当該オブジェクトのインスタンス変数を操作するメソッドがひとまとまりになっている場合もあります</li>
</ul>
<ul>
<li>Java Bean のセッター、ゲッターは、合わせて 1 つの "feature" と見なされています</li>
</ul>
<ul>
<li>[CJ2EEP] の 'Data Access Object' はオブジェクトの読み書きそれぞれを行うメソッドを提供します</li>
<li>別々にテストするのは困難です</li>
<li>そこで私達は、あるオブジェクトの読み書きをすることを 1 つの "feature" として取り扱っています</li>
</ul>
</div>
<div>
<h3>Variation: Testcase Class per User Story</h3>
<ul>
<li>それぞれのストーリーのテストメソッドを、異なるテストケースクラスに置きます<ul>
<li>XP のように漸進的な開発をしている場合は有用な方法です</li>
</ul></li>
<li>このプラクティスはコミットに関連した衝突を回避します<ul>
<li>同じ SUT クラスを使って別のストーリーを開発しているメンバーがいる場合など</li>
</ul></li>
<li>このパターンは、最終的な結果が他のパターンと同じになったりならなかったりします<ul>
<li>ユーザーストーリーをどのように分割するかによります</li>
</ul></li>
</ul>
</div>
<div>
<h2>Implementation Notes</h2>
<ul>
<li>テストケースクラスが SUT の 1 つの機能に対する要求を示すようになります<ul>
<li>テストケースクラスの名前が、テストが検証する機能を示すような名前となるように働きます</li>
<li>テストメソッドの名前も同様です</li>
</ul></li>
<li>この命名規則は、テストケースクラスやテストメソッドの名前を見るだけで、テスト条件を一瞥できるようにします</li>
</ul>
<ul>
<li>1 つの結果として、1 つのプロダクションクラスに対する多数のテストケースクラスが作成されます</li>
<li>1 つのクラスに関連する全てのテストを実行したくなるので、全てのテストケースクラスは、1 つのフォルダ・パッケージ・名前空間に入れるべきです<ul>
<li><em>Test Enumeration</em> (pp.399) を使っているなら、<em><a href="AllTest">AllTest</a> Suite</em> (<em>Named Test Suite</em> pp.592) によって 1 つのテストスイートに集めることができます</li>
</ul></li>
</ul>
</div>
<div>
<h2>Motivating Example</h2>
<ul>
<li>例では、<em>Flight</em> クラスのテストメソッドを <em>Testcase Class per Class</em> パターンによって構成しています<ul>
<li><em>Flight</em> クラスには 3 つの状態 (<em>Unscheduled, Scheduled, <a href="AwaitingApproval">AwaitingApproval</a></em>) があります</li>
<li><em>Flight</em> クラスには 4 つのメソッド (<em>chedule, requestApproval, deSchedule, approve</em>) があります</li>
</ul></li>
<li>ステートフルなクラスなので、少なくとも 1 つのメソッドごとに 3 つの状態でのテストが必要です<ul>
<li>省略した部分は <em>Testcase Class per Class</em> の章にあります</li>
</ul></li>
</ul>
<ul>
<li>例では、<em>Fresh Fixture</em> (pp.311) を構成するために ''Delegated Setup' (pp.411) を使っています<ul>
<li>宣言的にフィクスチャを構築しているせいか、ちょっと長いし、ごちゃごちゃしています</li>
<li>4 つの異なるテストメソッドがあるのも影響しています</li>
</ul></li>
<li><em>Testcase Class per Future</em> パターンにリファクタリングするにはよい例でしょう</li>
</ul>
</div>
<div>
<h2>Refactoring Notes</h2>
<ul>
<li><em>Testcase Class per Future</em> パターンに変換することで<ul>
<li>テストケースクラスを小さくできます</li>
<li>テストメソッドの名前を意味のあるものにできます</li>
</ul></li>
</ul>
<ul>
<li>最初に、どれだけのテストケースクラスを作るか決めて、テストメソッドがどこに入るべきかを決めます<ul>
<li>他と比べて小さくなりそうなテストケースクラスがあれば、そこから始めれば仕事がやりやすくなります</li>
</ul></li>
<li>2 番目に、<em>Extract Class</em> によって新しいテストケースクラスを作り、exercise する機能を説明する名前を付けます</li>
<li>3 番目に、<em>Move Method</em> (コ・ピ・ペ) によって、テストメソッドを関連するインスタンス変数もろとも新しいクラスに移動します</li>
</ul>
<ul>
<li>1 つの機能について、元となるテストケースクラスに対して上述の手順を繰り返します<ul>
<li>新しいテストケースクラスの名前は検証する機能に沿った名前に変えます</li>
<li>全てのテストケースクラスはコンパイル・実行できていなければなりません</li>
</ul></li>
</ul>
<ul>
<li>まだ完了してません</li>
</ul>
<ul>
<li><em>Testcase Class per Future</em> パターンの恩恵を受けるため、もうひと手間</li>
</ul>
<ul>
<li>それぞれのテストメソッドが検証する内容を意図した名前となるよう、<em>Rename Method</em> を行います<ul>
<li>最初にあったテストメソッドの名前に関する言及を削除できるようになる</li>
<li>必要な情報はテストケースクラスの名前に含まれているから問題ない</li>
<li>テストメソッド名に初期状態と期待結果を含めるような世界から我々を開放してくれた</li>
<li>機能ごとに複数のテストを持っている (メソッド引数が異なる) 場合<ul>
<li>テスト条件の関心事を含むようなテストメソッド名を考えましょう</li>
</ul></li>
</ul></li>
</ul>
<ul>
<li>このリファクタリングを実施する別の方法<ul>
<li>元のテストケースクラスをコピーして名前を変えます</li>
<li>不適切なテストメソッドを削除します</li>
<li>全てのテストメソッドを削除しないように注意しましょう</li>
<li>テストケースごとにコピーを作りながら作業することで間違いを避けることができます</li>
<li>全てが終わったら元のテストケースクラスを削除します</li>
</ul></li>
</ul>
</div>
<div>
<h3>Example: Testcase Class per Feature</h3>
<ul>
<li>メソッド名以外 (つまりメソッドの実装) は変更していません</li>
<li>メソッド名には、事前条件 (フィクスチャ)、exercise する機能、期待結果が含まれるようになりました</li>
<li>図 24.2 のような IDE のアウトラインビューによって、テストの一覧を見るだけで全体像が分かるようになります<ul>
<li><em>Tests as Documentation</em> (pp.23)</li>
</ul></li>
</ul>
</div>
</body>
</html>
